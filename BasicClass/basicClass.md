# 构造函数
1. 名字查找和类的编译
- 首先，编译成员的声明，在所有成员都可见之后再编译函数体。
- 名字查找时先查找所在的函数块，然后在类内查找，然后在定义函数体之前的语句查找，包括类的外部。
- 类型成员尽量定义在类的开头部分，这样可以避免类的外部和类的内部使用了相同标识符的类型成员变量而出现歧义，甚至编译器不会报错。
- 字面值常量类和委托构造函数，一个字面值常量类一定要有一个constexpr构造函数，且数据成员都是字面值常量类型。一个constexpr构造函数函数体为空的函数。
2. 友元  
- 友元通常出现在类的开头
- 对每个重载的函数都是进行友元的声明，如果必要的话。
- 友元只是让编译器可见。即使在类内在friend标识符下定义了一个友元函数，也需要在外部类外定义这个函数。
3. 静态成员和成员函数和静态成员函数
- 成员函数不是数据成员(data member)
- 当使用sizeof计算一个类（对象）的大小时，是没有包括成员函数的（尽管成员函数可以理解为一个函数指针，成员函数被视为指令，在test segment），,也没有包括静态成员。  
- 静态成员变量一般在类外部初始化，即一般在某个源文件的所有函数体外定义。如果在某个函数内定义会出现编译错误。  
- 常量静态成员可以在类的内部进行初始化。要求静态成员必须时字面值常量类型。
- 如果非常量静态数据成员在类的内部进行初始化，那么可以出现多次定义的情况，从而出现编译错误。
- 静态成员函数只能使用静态数据成员，因为静态成员函数并不包含this指针。
- 静态成员函数可以用于成员函数的默认实参。
- 在源文件中初始化静态数据成员时，尽管时private也可以通过作用域运算符进行定义。如 ```int A::a=234;```


4. 默认构造函数  
默认构造函数，即不需要传入参数的构造函数。如string（）；合成的默认构造函数：编译器自己合成的构造函数。 编译器自会为没有定义任何构造函数的类定义合成的默认构造函数。但可以通过显示=default定义合成的默认构造函数。  
- 委托构造函数：delegate construction  

```c++
dot(double x=0,double y =0,string x="blue"):x(x),y(y),x(x){}
dot(string x="blue"):dot(0,0,x){}
```
 - 带有引用或者指针成员的构造函数使用显示构造最好。
 - 构造函数不能声明为const。
 - 构造函数中的实参可以使用静态成员，因为静态成员属于类但是不属于对象。静态成员定义在data segment，作用域属于类作用域。在初始化数据成员的时候，尽量使初始化的顺序与数据成员声明的顺序一致。  
 

 ### 类成员指针
成员指针是可以指向类的非静态成员的指针。**成员指针指向的是类的成员而不是某个对象** 。 成员指针的类型囊括了类的类型以及成员的类型。当初始化一个成员指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供对象。  
声明一个成员指针： type classname::* ptr;  
初始化或者赋值一个成员指针：type classname::*ptr= &classname::member;   auto ptr= &classname::member;  
成员指针访问运算符.* 和->*; 该运算符会解引用指针并获得该对象的成员。  
一般而言，数据成员都被声明为private的，如果要使用指向数据成员的指针，我们可以添加一个返回某个数据成员的指针的函数。该函数应该为**静态**的。
``` c++
class a{
    private double d;
public:
    static const double a::*d(){return &a::d;} 
};
```
成员函数指针：如 auto　pmf=&a::f();  auto pmf1= &a::f()const & ;如果成员函数时const成员或者引用成员，我们必须将const限定符和引用限定符包含进来。  使用成员函数指针： (obj.*pmf)(args); 原因，调用运算符的优先级较高。  如果成员函数存在重载问题，我们必须显式地声明函数的类型。  如：
char (a::*pmf) (int,int) const ;  成员函数指针不是一个可调用对象，因为它需要通过类的对象来调用。  可以使用下面的方法生成可调用对象。  
function类，mem_fn,  bind;

###　嵌套类  
一个类可以嵌套在另一个类的内部，前者被称为嵌套类。　　
嵌套类和外层类相互独立。　　
嵌套类的名字（name of nested class）在外层类的作用域中可见，在外层作用域之外不可见。  嵌套类也使用访问限定符来控制外界对其成员的访问权限。外层类与嵌套类相互之间没有特殊的访问权限。  嵌套类的访问权限由其所在的外层作用域的位置决定。  

嵌套类的静态成员应该在外部类的外部定义。
名字查找的规则仍然适用，即我们可以使用外部类的类型成员（**数据成员不可以，因为两个类相互独立，而类型成员和静态函数不属于对象，属于类**）。  
```c++
#include<iostream>
class a{
    int a ;
    int c;
    using kfc=float;
    static void g(){
        std::cout<<"hello cindy"<<std::endl;
    }
public:
    int z;
    class bbs{
        double d;
        void f(){
            kfc sjaf=32;//kfc是一个类型成员，通过名字查找可以找到
            g();// g是一个静态成员函数，内层作用域在名字查找时会进行查找
            cout<<a; // a依赖于对象，是一个数据成员
        }
    };
};  
```

### 局部类
局部类是定义在某个函数内部的类。局部类的所有成员必须在函数内部进行定义。 且局部类不能由静态成员。 局部类不可以使用外部作用域的一般变量，只可以使用外部函数的类型名，静态变量以及枚举成员。  嵌套的局部类还是一个局部类，所以也只能在函数内部进行定义。

### 枚举
枚举类型将一组整形常量组织在一起。枚举属于字面值常量类型。  
限定作用域的枚举类型 enum class what {} or enum struct what {} 这两种等价。  
未限定作用域的枚举类类型 enum what {};  
如果enum是未命名的（不限定作用域的），则我们只能在定义该enum时定义它的对象。  
在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域之外是不可访问的。 在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身所在的作用域相同。  
由于枚举成员本身就是常量表达式，我们可以用于case 语句中，可以用于非类型模板参数，并可以作为类的静态成员能在类的定义中进行初始化。  
enum对象初始化或者赋值的时候，必须使用该类型的一个枚举成员或者该类型的另一个对象。   
```c++
enum class a ; //限定作用域的枚举类型可以这样前向声明；限定作用域的枚举成员的默认类型为int
//enum b;//未限定作用域的枚举类型的成员没有默认类型，故在声明时必须提供成员的大小。
enum c:int;// 正确的声明。
enum color{red,black ,yellow};
//enum like{red,black};//错误，重复定义了枚举成员red,black;
enum class hate{red,black ,yellow};//正确，枚举成员被隐藏了。
color eyes=black ;//正确，未限定作用域的枚举成员的作用域未枚举所在作用域。
color hair= color::yellow;//正确
enum c{
    sjd,dfj,fwjoe,hgwoeg
};//正确，定义c。
enum class a {
    jflsa,vniwev
}; //正确，定义a;
hate banana=red;//错误，类型不匹配，一个为hate,一个为color
hate banana =hate::yellow;//正确；
color y=23;//错误，类型不匹配
int i=red;//正确。  
void f(){
    enum dark{black,purple};
}
dark m=dark::black;//错误。
```

### union 
见cpp




