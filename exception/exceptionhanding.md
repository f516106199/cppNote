## exceptino handling  
在c++中，通过throw一条语句来引发一个异常，被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码将被用来处理该异常。  
当执行一个throw时，跟在throw后面的语句将不再执行。程序的控制权将从throw转移到与之匹配的catch模块。控制权从一处转移到另外一处有两个含义：  
> 1.沿着调用蓝的函数可能会提早退出  
> 2.一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。  

### 栈展开
栈展开： 栈展开过程沿着嵌套函数的调用链不断查找与之匹配的catch子句，直到找到了与一场匹配的catch子句为止，或者也可能一直没有找到匹配的catch，则推出主函数后查找过程终止。  
假设找到了一个匹配的catch字句后，则程序进入该子句，并执行其中的代码。当执行完这个catch字句之后，找到与try块关联的最后一个catch子句之后的点，并从这里继续进行。如果没找到匹配的catch子句，程序将退出，调用标准库函数terminate。  

### 析构函数与异常
析构函数总是会被执行，但是函数中负责释放资源的代码可能被跳过。所以显而易见的，如果一个块分配了资源，并且在负责释放这些资源的代码前面发生了异常，则四方这些资源的代码将不会被执行。  
析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。栈展开的过程中可能会调用析构函数，析构函数因此不应该抛出自己不能处理的异常。析构函数如果会执行某个可能抛出异常的操作，则该可能抛出异常的操作应该放置在一个try语句块中，并在析构函数内部得到处理。  

### 异常对象  
异常对象位于编译器管理的空间中，编译器确保无论最终调用的是哪一个catch子句都能访问该空间。**当异常被处理完毕之后，异常对象被销毁**。　　
注意：
> 当我们抛出一个表达式时， 该表达式的静态编译时类型 决定了异常对象的类型。因此如果一条throw表达式解引用一个被声明为指向基类的指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有积累部分被抛出。    
> 不要使用指向局部对象的指针作为异常对象。因为可能该局部对象已经被释放。  
> 编译器使用异常抛出表达式来对异常对象进行拷贝初始化。 因此throw语句中的表达式应该拥有完全类型。 且如果时类类型的话，应该具有可访问的析构函数和拷贝（移动）构造函数。  
> 如果表达式时函数或者数组类型的话，表达式被转化为对应的指针类型。  
 
### catch子句与异常声明： 
关键字catch后面的括号里面一个（可能未命名）对象的声明被称作异常声明。 声明的类型决定了处理代码所能捕获的异常类型。它可以是左值引用，但不可以是右值引用。因为右值引用只能引用一个右值，**而异常对象在异常被处理完毕之后，才进行销毁**    
通常情况下，如果catch接受的异常与某个继承体系有关，则最好将catch的参数定义为引用类型。  
#### 查找catch子句 
catch子句按照出现的顺序逐一进行匹配，因此应该将最特殊（继承链最低端（most derived type））的catch放在前面。   
在catch子句中允许的类型转换如下： 
>- 允许非常量向常量的转换.就是说，一条非常量的throw语句可以匹配一条接受常量引用的catch语句。  
>- 允许派生类向基类的转换   
>- 数组被转化为指向数组（元素）类型的指针，函数被抓换位指向该函数类型的指针。  
除此之外，包括算术类型的转换和类型转换在内，其他所有抓换规则都不能在匹配catch的过程中使用。  

### 重新抛出
重新抛出指的是在一个catch子句里面或者catch子句直接或间接调用的函数里使用了空的throw语句。  如果在其他地上使用了catch子句，那么编译器会调用terminate。  
一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。如果异常声明时使用了引用，那么可能会修改异常对象的值，从而被重新抛出。形如catch{...}通常与重新抛出语句一起使用，它能够捕获所有的异常。并一般出现在catch子句的最后面。  

### noexcept 
noexcept说明符： 出现在成员函数的const，引用限定符之后，override, final限定符，=0之前。     同时，使用尾置返回类型时，它出现在尾置返回类型之前。 编译器不会为一个声明为noexcept却抛出异常的代码给出警告。  可以将函数指针声明为noexcept，这样的指针不能指向可能抛出异常的函数。  
noexcept只是告诉编译器这个函数不会抛出异常，但是不能肯定这个函数就不会抛出异常。noexcept的好处是，对于真正不会抛出异常的代码，编译器会执行优化。

noexcept做说明符的时候，可以有异常参数。 如：  ret_type f(args) noexcept(true); 或者 ret_type f(args) noexcept(false);  
noexcept运算符： noexcept不回计算表达式的值，判断是否抛出异常。noexcept返回常量右值布尔表达式。  noexcept运算符可以和说明符一同使用。  如： ret_type f(args) noexcept(g());如果函数g()不抛出异常，那么f()不抛出异常。  

如果一个虚函数承诺不抛出异常，那么它的派生版本也应该如此。  相反，如果虚函数可能派生异常，派生的函数可以（不）抛出异常。  
