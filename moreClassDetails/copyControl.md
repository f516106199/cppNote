## 拷贝控制成员
拷贝构造函数 拷贝赋值函数 析构函数 移动构造函数 移动赋值函数   

拷贝控制成员都可以显式的声明为=default的形式，或者=delete的形式。如果某些类不能拥有某个拷贝控制成员，则即使使用了=default的形式，拷贝控制成员仍然是=delete。  
当使用=default时，因为函数的定义可以出现在类内或者类外，=default就意味着定义，=default可以不出现在第一次声明中，但是=delete一定要出现在第一次声明中。  

1. 拷贝构造函数  
构造函数的第一个参数为自身类类型的引用（一般情况下为常量引用），其余形参都具有默认值，则为拷贝构造函数。  
>编译器会为没有定义自己版本的拷贝构造函数的类定义自己的合成拷贝构造函数。  
拷贝初始化一般发生在下面几种情况中： 
>>- 拥有非引用返回值的函数的返回值  
>>- 当给可调用对象传入非引用类型的对象时  
>>- 当使用花括号进行初始化时，对象里面的每个元素使用拷贝初始化。  
>>- 一般情况下，push_back使用拷贝（移动）初始化，而emplace_back使用直接初始化，直接构造。   
>>- 是否使用explicit需要自己掂量。  

2.拷贝赋值函数   
拷贝复制函数的参数应该就是自身类类型的引用（一般情况下为常量引用），使用了重载运算符。  
>编译器会为没有定义自己版本的拷贝赋值函数定义自己的合成版本。  
>是否使用explicit需要自己掂量。  

### adding ：左值，右值，左值引用，右值引用，move函数。
左值：locator value 简称lvalue。左值是具有内存地址的值，have a addresss 。  故变量都是左值。  
右值：rvalue 。右值是一个临时量，即将销毁的值。  右值也可以被赋值，分为常量右值和非常量右值。   
左值引用： 左值引用可以引用左值，也可以引用右值。引用右值时，一般使用的是常量引用。     
右值引用： 右值引用只可以引用右值。右值引用本身是变量是一个左值。  
move函数生成一个对象的右值，使用move函数之后就意味着我们移后不会再使用移后源。  
```c++
 int za=32;
 int &tref=std::move(za);//错误，左值引用要引用右值只能使用常量引用
 const int &a=32;//常量引用可以引用右值。等价于 const int temp=32; const int &a=temp;
 int &&b=323;//右值引用，右值引用只能够引用右值，右值引用本身是一个变量，所有右值引用本身是一个左值。
 int&x=b;//右值引用是一个左值。
 int&&y=b;//错误，右值引用智能引用左值。
 int &&z=std::move(b);//正确，move函数返回一个右值。
 ```
3.移动构造函数
构造函数的第一个参数是自身类类型的非常量右值引用，其余参数具有默认值，则为移动构造函数。
>编译器不会为定义了拷贝构造函数，拷贝赋值函数或者析构函数的类定义合成的移动构造函数。  
>移动构造函数不会被隐式的定义为=delete。我们可以显式地使用=delete。如果我们使用=default，但是类本身的移动操作是不合理的，则编译器会将移动操作定义为删除的。  
>noexcept用于指明该函数不应该抛出异常，通常情况下移动操作会使用noexcept，在确保该函数不会发生异常的情况下我们可以使用noexcept。  
>定义了一个移动构造函数或者移动赋值函数的类也必须定义自己的拷贝操作 。否则，这些成员默认地被定义未删除的。  
>应该保持移后源处于可析构的状态。  

4.移动赋值函数
移动复制函数的参数是自身类类型的非常量引用。其余与移动构造函数类似。  
值得注意的是，移动复制函数需要判断是否用自身赋值自身，从而出现异常。  

**如果一个类没有定义移动操作，编译器会通过拷贝操作来代替对应的移动操作。只有当一个类没有定义任何拷贝控制成员，且类的每个非static成员都可以被移动时，编译器才会为它合成移动操作。**  

5。析构函数 
析构函数名由波浪线加类名组成，没有返回类型和参数。  
执行析构函数时，先执行函数体的内容，然后按照成员初始化的逆序进行销毁。    

**五个拷贝控制成员应该被视为一个整体，如果定义了其中一个，就应该定义剩下的所有。**

### 移动迭代器
普通迭代器解引用返回的是一个左值，移动迭代器解引用返回的是一个右值。使用函数make_move_iterator（）将一个普通迭代器转换为移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器。可以将移动迭代器用于泛型编程。 如 uninitialize_copy(-n) uninitialized_fill(-n);  

### 右值和左值引用成员函数
通常，我们在一个对象上调用函数，而不管该函数是一个左值还是右值，我们可以使用引用限定符来指明this指针指向一个右值或者左值。引用限定符可以是& 或&&，同样的，引用限定符只可以作用于非static函数。
```c++
string a ="fjsdaf" ;string b="fj9e";
a+b="fjsdijfisdojf"// 对一个右值进行了赋值。
class foo{
public:
  foo& operator=(const foo&)&;//左值引用成员函数，只能向可修改的左值赋值
  //foo的其他参数。
}；
foo &foo::operator=(const foo &rhs)&{
  //执行
  return *this;
}
``` 
**如果一个成员函数具有引用限定符，则重载的有相同参数列表的所有版本都必须由引用限定符。**
