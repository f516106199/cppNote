## mutiply inheritance 
在派生类的派生列表中可以包含多个基类。每个基类包含一个可选的访问说明符。一如既往，如果访问说明符被忽略了，则class对应private，struct对应public。   同样的，派胜率表里面只能是被定义过的类，且同一个基类只能出现一次。  

派生类中，先构造基类的内容，再构造派生类的内容。其中基类的构造顺序与**派生列表**中基类的出现顺序一致。而与派生类构造函数初始值列表中基类的顺序无关。 执行析构函数的时候，其顺序与构造的顺序相反。  

多继承中，如果使用继承的构造函数，要注意可能出现某两个基类的构造形参列表一致的情况。  如果遇到这样的情况，应该自己重新定义此版本，否则会报错。  

仍然可以令某个可访问基类的指针或引用直接指向一个派生类对象。  编译器不会在派生类像基类的转换中做出比较和选择，因为在它看来转换到任意基类都一样好。  

在多重继承的情况下，相同的查找过程将在所有直接基类中进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。   同样的，名字查找优先于类型检查。  

## virtual inheritance
虚继承与虚基类。  虚继承的目的是令某个类作出声明，承诺共享它的基类。 其中共享的基类对象被称为虚基类。  
需派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。     

指定虚基类的方式是在派生列表中添加关键字virtual。  

虚基类是由**最低层（most derived**的派生类初始化的。虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。    一个类可以有多个虚基类。此时，这些虚的子对象按照他们在派生列表中出现的顺序从左往右依次构造。  析构的顺序正好相反。


