## 虚函数：
> 任何构造函数之外的非静态函数都可以是虚函数。一个函数被声明为虚函数，这个函数在派生类也隐式地是虚函数。  
> 虚函数实现了多态，派生类可以直接继承基类的虚函数，也可以覆盖(重新定义)虚函数。未经覆盖直接继承的虚函数还是存在于外层作用域（基类的外层），而覆盖的虚函数存在于内层作用域（派生类）。  
> 虚函数也可以进行重载。需要注意的是，对于c++而言，名字查找优先于类型检查，因此内层作用域的函数不会重载外层作用域的函数，而是隐藏外层作用域的同名函数。 所以，在重载虚函数的时候，一定要保证参数列表相同，在返回机身类型的引用的时候可以例外（但是要满足从派生类到基类的转化是可行的），否则会出现意外的错误。  同时， 如果我们要使基类虚函数的所有重载类型对于派生类都可见，我们应该覆盖其中的所有或者0个虚函数。 当然，我们可以使用using 声明使基类的重载成员都可见，然后自己重定义需要被覆盖的版本就即可。  
> final 和 override声明符。 对于在派生类中进行了覆盖的虚函数，我们最好都是用override 声明符来显示地表明我们覆盖了虚函数，以防止出现定义了一个其他的函数的错误。override 一般写在const和引用修饰符以及尾置返回类型之后。 声明为final的虚函数或者类不可以被覆盖或继承。  
> 虚函数也可以有默认实参，调用虚函数时默认实参决定于静态类型。 不过通常情况下，基类和派生类中定义的默认实参一致。
> 回避动态绑定， 可以通过作用域运算符来回避虚函数（多态）的机制。 如 a-> base::f();
> 纯虚函数 纯虚函数无需定义但是可以定义，在声明语句的分号之前书写=0的虚函数就是纯虚函数。其中，=0 只能出现在类内部的虚函数声明语句处。 为纯虚函数提供定义，不过函数体必须出现在内的外部含有纯虚函数或者未经覆盖直接继承纯虚函数的类是抽象基类。我们不能创建一个抽象基类的对象。  
>析构函数通常是虚函数。就经验而言，定义了析构函数的类一般也定义自己邦本的拷贝和移动操作，但是虚析构函数不一定。  
## 派生访问列表和三种成员：
三种成员：
public:都可访问   
private: 仅有友元和在类的成员可以访问。  
protect： 友元，类成员，派生类都可以访问。  
派生访问列表：  
形如 class a :  public b, private c , protectec d  {};   
三种继承关系：
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/table-class.png)   
class 默认采用private 继承， struct 默认采用public 继承   
通过使用using 声明，可以改变基类被继承成员在派生类的访问属性，其中，改变后的访问行取决于using声明位于什么访问声明符之后。  

### 继承的构造函数
派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。 例子：  
 ```c++
 class buck_quote : public dis_quote{
 public:
   using disc_quote:disc_quote;//继承的构造函数
   double net_price (std::size_t)const;
};
```
通常情况下，using声明只是使某个名字在当前作用域可见。而当作用于构造函数时，using声明语句将令编译器产生代码（产生的代码时派生类的构造函数，参数和基类的相同），并不会改变访问权限。 如果派生类还含有自己的数据成员，那这些成员将被默认初始化。    
using声明也不能指定explicit和constexpr；  
当一个积累含有默认实参，这些实参并不会被继承。相反，派生类会获得多个继承的构造函数，其中每个构造函数分别省略一个含有默认实参的形参。  
如果派生类含有多个构造函数，派生类会继承除了默认，拷贝，移动构造函数和自己定义的具有相同参数列表的构造函数。  继承的构造函数不会被视作用户定义的构造函数，因此，如果一个类仅含有继承的构造函数，则它也将拥有一个合成的默认构造函数。   

### 容器和继承
当我们需要使用容器来同时容纳基类和派生类的对象时，储存的都是指向基类的指针。  
对于容器的某些参数为指针的操作，可以定义对应的参数为非指针的操作。 通过生成一个有参数值而创建的指针。引用或智能指针。但是在产生指针时，要注意不要发生对象数据成员被切断的错误。  
如：
```c++
void add_item(const base& sale){
bsk.add_item(new base(sale)); // sale可能是一个派生类的对象，但是这条语句产生的指针指向的对象可能并没有派生类的数据成员。
```  
因此我们可以为基类或者派生类定义一个名为clone的虚函数
``` c++
virtual base* clone()&&{return new quote(std::move(*this));}
virtual base* clone()const &{return new quote(*this)};
```

 


