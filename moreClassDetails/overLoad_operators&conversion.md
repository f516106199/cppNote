## 运算符重载
重载的的运算符是具有特殊名称的函数，他们的名字有operator加上要定义的运算符号构成。和其他函数一样，重载运算符也包含返回类型，参数列表以及函数体。  Type operator __ (Types);   
重载的运算符应该作为一个类的成员或者至少含有一个类类型的参数，意味当运算符作用域内置类型的对象时，我们不能改变其含义。是否将重载运算符定义为成员函数取决于原生操作符的运算规则。  
- 赋值，下标，解引用，成员访问->运算符必须是成员。
- 符合运算符一般是成员，但并非必须。  
- 改变对象状态的运算符应该是成员。 如++ --   
- 具有对称性的运算符可能转换任一侧的运算对象，如算术，相等性，关系，位运算符应该为非成员。  

### 相等运算符和关系运算符。
### 相等运算符
>- 如果类含有判断两个对象是否相等的操作，则它显然应该定义为operator==而非一个普通的成员函数，提供==更加方便记忆和使用，以及方便使用泛型。
>- 如果类定义了operator== ，则也应该定义operator！= 
>- 相等运算符和不相等运算符应该把其中一个函数的工作委托为另外一个，可以避免出现错误。 
### 关系运算符
>- 如果要定义关系运算符，关系运算符的逻辑应该和相等运算符的逻辑一致。

### 递增和递减运算符
递增和递减运算符在没有参数的情况下视为前置版本。如果递增和递减运算符的形参有一个int类型的参数，则视为后置版本，在传入参数的时候一般传入0，编译器会视为后置++。  

### 成员访问运算符
箭头运算符和解引用运算符必须是类的成员。
对于a->mem.  
1. 如果a是一个指针，则使用的是内置的箭头运算符，表达式等价于（*a）.mem. 首先解引用指针，然后从获得的对象中获取指定的成员。如果a所指的类没有该成员，则会报错。  
2. 如果a是定义了operator->的类的一个对象，则使用a.operator->来获取mem。其中如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的operator->() ，则重复该步骤。最终，当这一过程结束时程序或者返回了所需 的内容，或者返回报错的信息。即当我们给自己的类定义operator->时，一般时返回一个指针，然后让指针继续去调用mem。  

***在类的内部如果能够使用委托的方式定义一个函数就尽量使用委托的形式*** 

### lambda
lambda 是函数对象。
``` c++ 
auto f = [](const int a ,const int b ){return a+b;}; 
class A {
   int operator()(int a ,int b){return a +b;};
};
auto ff =[a,b](const int c, const int d){return a*b-c*d;};
class B{
public:
   int operator()(int c,int d ){return a*b-c*d;};
private:
  int a;
  int b;
};

// lambda 表达式等价于类a的一个未命名对象。 f 相当于A的一个未命名对象，ff相当于B的一个未命名对象。

``` 

### 可调用对象于function
c++中的可调用对象：函数，函数指针，lambda表达式，bind创建的对象， 重载了函数调用运算符的类。  
不同类型调用对象可能拥有相同类型的调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。  使用function类型来统一表示可调用对象，function定义在头文件functional中。  

### 类型转换运算符
类型转换运算符是一种特殊成员函数，他负责将一个类类型的值转化为其他类型。 类型转换的一般形式如下所示：operator type() const；
通过使用explicit告知编译器不能进行隐式的类型转换。  
tips：
>应该避免具有二义性的类型转化
>通常情况下定义一个转化为算数类型的类型转换运算符为佳。
>类型转换通常还会和其他如运算操作符产生二义性。例如，如果一个类定义了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。 


