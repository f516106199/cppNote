# 模板
>生成某个具体类型的模板被称之为模板的实例化。  
>通常情况下，我们使用了某个特定版本的模板，我们实例化一个特定版本的模板，并生成代码。对于类模板而言，隐式实例化只会一步步实例化那些使用到的成员。即如果类模板中有某个成员没有   
>被使用，那么该成员不会被实例化。
>模板参数遵循普通的作用域规则，一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。在模板内不可以重用模板参数名。即一个模板参数名只可以在模板参数列表中出现一次  
>并且在模板内不能再定义与模板参数同名的变量。  
### 默认实参
我们可以为函数模板和类模板提供默认实参  
eg   
template <typename T ,typename F=less<T> >  
int compare(const T&val1,const T&val2,F f=F()){}  
#### 模板默认实参和类模板
无论何时使用一个类模板，都必须在模板名后面接尖括号对，如果我们希望使用默认实参，就可以使用空的尖括号对。  
### 隐式实例化和显式实例化
- 隐式实例化
当我们使用了模板的某个实例时，这个实力会被隐式实例化。 如果多个源文件中使用了同一个模板的同一种版本类型，那么每个源文件在编译时都会被写入该实例版本的代码，虽然最后会进行截取从而保留唯一一个实例化代码，但是会增加编译的时间和成本。   
- 显式实例化
形式：  
extern  template declaration; // 实例化生命  
template  declaration; //实例化定义。   
declaration 是一个类或函数声明，并且其中的所有模板参数都被替换为模板实参。  
eg:  
extern template class blob<string>;//声明，当编译器遇到extern时，它不会在本文件中生成实例化代码。extern意味着承诺程序在其他位置由该实例化的一个非extern声明（定义）。  
template int compare(const int & ,const int &);//定义   
当编译器遇到实例化定义时，它为其生成代码。因此.o文件会包含compare的int实例化版本的定义或blob<string>的定义。  
类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，他不了解程序会使用那些成员函数，因此它与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。 故在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员。  
## 模板编译  
>编译器遇到模板定义时，并不立即生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成相应版本的代码。 通常，调用一个函数只需要知道函数的声明，当我们使用一个类时，只需要类的定义是可用的，而成员函数的定义可以不必出现，所以我们一般将函数的声明和类的定义放在头文件，而普通函数和成员函数的定义放在头文件。模版则不同：为了生成一个实例化版本，编译器需要掌握函数模板或者模板成员函数的定义。因此，模板的头文件通常包括声明**和**定义。  
对于使用了模板的代码，编译器通常会在三个阶段报告错误。
>- 第一个阶段是编译模板本身。这个阶段编译器负责检查语法错误。  
>- 第二个阶段是编译器遇到模板使用时。对于函数模板，编译器通常检查参数数目是否正确，参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参。  
>- 第三个阶段是模板实例化时，只有这个阶段才会发现类型相关的错误。依赖于编译器如何实现实例化，这类错误可能在连接阶段才报告。  
>- 模板的实例化分为隐式实例化和显式实例化，对于模板的使用是隐式实例化，故模板的隐式实例化应该发生在模板的使用之后的某个具体时间但不清湖，因此分为第三阶段（不一定正确的本人的理解）  

## 函数模板  
模板定义以关键字template开始，后跟一个模板参数列表，这是由逗号分隔的一个或多个模板参数的列表，用<>包围起来。 当使用函数模板时，我们隐式地指定模板实参，将其绑定到模板参数上。  
模板参数可以是类型参数或者非类型参数，类型参数前必须使用typename或者class关键字，一般使用typename关键字更好。  非类型模板参数。当我们实例化一个模板时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式，从而允许编译器在编译时实例化模板。  
**函数模板可以被声明为inline或者constexpr的**  inline或者constexpr说明符放在模板参数列表之后，返回类型之前。

## 类模板
与函数模板不同的是，类模板不能推断模板参数的类型，因此当使用类模板时，我们应该提供显示模板实参列表，他们被绑定到模板参数。  
>- 类模板的成员函数  
>  定义在类模板外的成员函数必须以template开始，后面接模板参数列表。 如：  
>template<typename T>  
>ret-type blob<T>::member-name(parm-list)  
>在类内部定义的话，则不需要。  
>- 类模板和友元  
> 一个类可以与一个模板的每一个实例成为自己的友元，也可以限定某个特定的版本使他成为友元。 为了让所有实例成为友元，友元声明中必须使用和类模板本身不同的模板参数。我们还可以将自己的类型参数  
> 声明为友元。  
>- 类型别名 
> 我们可以为模板或者模板的某个实例定义别名。  
> eg: template<typename T> using twin= pair<T,T>;   typedef blob<string> strblob;
>- 类模板的static成员
> 类模板的每个实例都有一个独立的static对象。即对于给定类型的实例，模板特定版本的所有实例都共享相同的对象
>- 使用类的类型成员
>在普通的类中，使用作用域运算符访问类型成成员和静态成员。但在模板代码中，假定T是一个模板类型参数，当编译器遇到T:: mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员  
>直至实例化才会知道。 故我们使用typename T::mem 来表明mem是一个类型成员而不是一个静态成员。
>- 成员模板
> 一个类可以包含本身是模板的成员函数，这种成员被称为成员模板。**成员模板不能是虚函数**。
## 变量模板  
template <形参列表>  变量声明 ；

## 模板实参推断
对于函数模板，编译器利用调用中的实参来确定其模板参数。从函数实参来确定模板实参的过程被称为模板实参推断。  
与平时一样，顶层const无论实在形参中还是在实参中，都会被忽略。能在调用中应用于函数模板的转换包含以下两项。
- const 转换：可以将一个非const对象的引用或者指针传递给一个const的引用或者指针。（显而易见的）  
- 数组或函数指针转换：如果**函数形参不是引用类型**，则可以对数组或函数类型的实参应用正常的引用转换。一个数组实参可以转换为一个指向其首元素元素的指针。类似的，一个函数实参可以转换为指  
向该函数类型的指针。  
其他类型，如算术类型，派生类到基类，用户定义的转换，都不能应用于函数模板。但是不涉及模板类型参数的类型会进行正常的类型抓换。
### 尾置返回类型和类型转换模板库
当返回类型可能由参数类型决定是，我们使用尾置返回类型。  
eg:   
template<>typename It>   
auto fcn(It beg, It end )-> decltype(*beg){}   
有时我们可能无法获得我们想要的类型，为了获得元素类型，可以使用标准库的类型转换模板。这些模板定义在type_traits中。 如 remove_reference add_lvalue_reference   .
### 函数指针和实参推断   
可以通过函数指针的类型类推断函数模板的类型；   
eg:  
template<typename T>int compare(const T&, const T&);  
int (*pf1)(const int&, const int &)= compare ; // 会确定compare的类型  
### 模板实参推断和引用  
- 从左值引用参数推断类型  
当一个函数参数是模板类型参数的普通左值引用时（like :T&）,我们只能向他传递一个左值。如果传递的是一个const类型，则T会被推断为const类型。  
当一个函数参数是模板类型形参的常量左值引用时（like: const T&），我们可以传递一个任何类型的实参。  
- 引用折叠和右值引用函数
> 1. 当我们向一个左值传递给右值引用函数，且右值引用指向模板类型参数（如：T&&），编译器会推断为T为int &   
> 2. 如果我们间接创建了一个引用的引用（通过给引用添加类型别名或者通过模板类型参数间接定义），这些引用会形成引用折叠。对于给定类型 x, x& x&& &  x& &&都折叠为x& ,  x&& &&折叠为x&&    
> 3. 转发引用。 转发引用是一种特殊的引用，它保持函数实参的值类别，使得可以利用std::forward转发实参。转发引用是下列之一  
> -  函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无 cv 限定的右值引用：  
``` c++
template<class T>  
int f(T&& x) {                    // x 是转发引用  
    return g(std::forward<T>(x)); // 从而能被转发
}
int main() {
    int i;
    f(i); // 实参是左值，调用 f<int&>(int&), std::forward<int&>(x) 是左值
    f(0); // 实参是右值，调用 f<int>(int&&), std::forward<int>(x) 是右值
}
 
template<class T>
int g(const T&& x); // x 不是转发引用：const T 不是无 cv 限定的
 
template<class T> struct A {
    template<class U>
    A(T&& x, U&& y, int* p); // x 不是转发引用：T 不是构造函数的类型模板形参
                             // 但 y 是转发引用
};
```
> 3. 再次强调，引用折叠只能应用于间接创建引用的引用。 在模板中，对于无cv限定的右值引用才满足上述规则（被称之为转发引用）。  
这3个规则导致了一个结果，T&&可以引用一个左值，如果实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将会被实例化为一个普通左值引用参数。  

标准库定义std::move()的方式:
```c++
template <typename T>
typename remove_reference<T>::type&& move(T&&t){
  return static_cast<typename remove_reference<T>::type&&>(t);//即使T是一个左值。也可以使用static_cast;
```
std::forward()的使用方法： 参考[cpp_reference](https://zh.cppreference.com/w/cpp/utility/forward) 和 [stackoverfolw](https://stackoverflow.com/questions/8526598/how-does-stdforward-work)  

##　模板重载
匹配问题：
同样好的函数中优先选择非模板函数；　如果同样好的函数中都是模板函数，优先选择更加特例化的函数；　　否则，调用有歧义。　　

## 可变参数模板 
一个可变参数模板就是接受可变参数数目的函数模板或模板类。 可变数目的参数被称为参数包。 存在两种参数包，模板参数包和函数参数包。  
在一个模板参数列表中，class...or typename... 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。  
[cpp_reference](https://zh.cppreference.com/w/cpp/language/parameter_pack)  

## 模板特例化
某些情况下，需要为特定版本的模板定义自己的特例化版本，这种行为称之为模板特例化。    
notes: 特例化的实质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。    
特例化的语法形式 template<> class<???>{}    template<> ret_type f(args){}    
我们可以对类进行部分特例化，如特例化一部分模板参数，或是参数的一部分而非全部特性，一部分成员模板等。 函数模板不可以进行部分特例化。  
特例化成员或是参数的一部分属性：  
```c++
template<>
void Foo<int>::bar(){}// 特例化成员，这里是int版本的foo类的bar函数。  
template<typename T>struct remove_reference<T&>{using type = T;}//特例化左值引用,即特例化参数的一部分特性。
```





···
